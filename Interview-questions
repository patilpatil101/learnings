Interview Question

HTML - 5

1. Difference between display block, inline-block and inline.
2. HTML 5 new tags.
3. What is the semantic and non-semantic element?
4. What is web storage?
5. Web workers in html5? Did you get a chance to work on web workers ? If yes please explain.
6. Difference between responsive and adaptive sites.

CSS - 3
1. Explain CSS Responsive breakpoints.
    // Small devices (landscape phones, 576px and up)
    @media (min-width: 576px) { ... }

    // Medium devices (tablets, 768px and up)
    @media (min-width: 768px) { ... }

    // Large devices (desktops, 992px and up)
    @media (min-width: 992px) { ... }

    // Extra large devices (large desktops, 1200px and up)
    @media (min-width: 1200px) { ... }


2. CSS Margin Collapse.
3. Difference between Pseudo-classes and CSS Pseudo-elements.
4. explain box model in detail.
5. List the position property and explain each property.
6. CSS combinators and explain descendant(space),child(>),adjacent sibling(+) and general sibling(~) selector.
7. Explain flexbox and all the property of flexbox.
8. What is media query.
9. Write the css three div in one row.
10. Explain css grid system.
11. What is Specificity?
12. How to write css variable.
13. What is width of below div
div {
  width: 320px;
  padding: 10px;
  border: 5px solid gray;
  margin: 0;
}
=> 350px

14. What is width of below div

div {
  width: 320px;
  padding: 10px;
  border: 5px solid gray;
  margin: 0;
  box-sizing: border-box;
}
=> 320px



SCSS

1. What is scss.
2. What is variable in scss.
3. What is Nesting,Partials,Import,Mixins,Inheritance and Operators.


Bootstrap 4

1. What is bootstrap.
2. Difference between container and container-fluid.
3. Explain grid system and end points(breakpoints).
3. What is utilities.
4. Explain all Flex class in bootstrap 4.0.
5. Button class in bootstrap and how to write it.


Javascript:
1. Shallow Copy vs Deep Copy
    =>
    The spread operator makes deep copies of data if the data is not nested. 
    When you have nested data in an array or object the spread operator will create a deep copy 
    of the top most data and a shallow copy of the nested data.


    const user = {
    name: 'Raj',
        location: {
            city: 'NY',
            state: 'NY'
        }
    };
    const copy = Object.assign({}, user);
    // OR
    // const copy = { ...user };
    copy.location.city = 'Albany';
    console.log('original: ', user.location);
    console.log('copy:', copy.location);

ANSWER:

    original:  {
    city: 'Albany',
    state: 'NY'
    }
    copy: {
    city: 'Albany',
    state: 'NY'
    }

Reason: The reason for the changed original object is because when we use Object.
        assign or spread operator, it only does shallow copy, which means while creating a copy of the object, 
        properties of only the first level are copied and if there are nested properties then only their 
        reference is copied which means the copied reference still refers to the original place where the 
        object is stored.



2.  
    var number = 10;
    var display = function () {
    console.log(number);
    var number = 20;
    };
    display();

Answer: The output of the above code is not 10 but it’s undefined

Reason: Hoisting is JavaScript’s default behavior of moving declarations to the top of the current scope or block.


3. 

    const number = 1;
    const result = (function () {
    delete number;
    return number;
    })();
    console.log(result);

Answer: 1

Reason: The delete operator is used to delete the property of an object. 
        Here, number is not an object but it’s a primitive type so it will not throw an error 
        but the function will return the original value of the variable which is 1


4. 
    const number = 1;
    const result = (function (number) {
    delete number;
    return number;
    })(10);
    console.log(result);

Answer: 10

5. 
    function display() {
    var a = b = 10;
    }
    display();
    console.log('b', typeof b === 'undefined');
    console.log('a', typeof a === 'undefined');

Answer: 
    b false
    a true

Reason: This is because the assignment operator has right to left associativity in Javascript which means it will be evaluated from right to left so first

6. 
    aaajjkk  output: a3j2k2

7. Find the missing numbers in a given integer array
    let arr = [1,3,2,6,5,7,8,10,12,11,15];

Answer: 
    function findMissingNumber(arr){
    const sortedArr = arr.sort((a,b)=>{return a -b});
    const missingNumbers = [];
    console.log(sortedArr);
    for(let i = 0; i < sortedArr.length - 1; i++){
        if(sortedArr[i+1] !== sortedArr[i]+1){     
            missingNumbers.push(sortedArr[i]+1);
        }
    }
  console.log(missingNumbers);
}
    findMissingNumber([1,3,2,6,5,7,8,10,12,11,15]);


1. JavaScript Data Types & 
    typeof []   => object
    typeof null => object
    typeof 'blubber' => string
    typeof Array => function
    typeof undeclaredVariable => undefined

2. What is Hoisting &
    
    var b = world();
    console.log(b);
    var world = function () {  
    return "world";              
    }
=> world is not a function

    const x;
    x = 5;
    console.log(x);            
=> error to variable x Missing initializer in const declaration

    console.log(x);
    let x = 5;  
=> x is not defined              

const arr = [1, 2, 1, 1, 2, 3, 2]         
arr[2] = 7 

=>[1, 2, 7, 1, 2, 3, 2]


const test = function (name) {
  const test1 = function () {
    this.name = name;
  }
  test1();
}

const obj = new test('Rohit');
console.log(obj.name)             
console.log(name)      
=> undefined
   Rohit

3. What is use of "Use Strict" in javascript.
4. Explain callback function
5. what is inheritance and can you write the syntax.
6. How to empty an array in JavaScript
const arrayList = ['a', 'b', 'c', 'd', 'e', 'f'];
=> 
arrayList = []
arrayList.length = 0;
arrayList.splice(0, arrayList.length);

 while (arrayList.length > 0) {
            arrayList.pop();
  }
  
  while (arrayList.length > 0) {
            arrayList.shift();
        }
		
console.log(arrayList);

7.
var a = 2 - 5 / 3 * 1 + 2;
console.log(a);
=> 2.333333333333333

8. 
const multiply = (a = 2, b = 3, c = 2) => a * b * c;
console.log(multiply(2)); 
=> 12

9. 
console.log(4 > 5 > 3 > 2 > false) 
=> false

10. 
console.log(1 < 2 < 3 < 2)
=> true

11.  (function () {
            console.log(1);
            setTimeout(function () { console.log(2) }, 1000);
            setTimeout(function () { console.log(3) }, 0);
            console.log(4);
        })();
		
=> 1 4 3 2

12. var person1 = { name: 'vishal', age: 20 }
I want kay and value
=>
console.log(Object.keys(person1)); //["name", "age"]
console.log(Object.values(person1)); //["vishal", 20]

13. const arr8 = [[1, 2], [3, 4], [null, [Infinity]], -2, 3, "vishal",[5, 6]]; 

[1, 2, 3, 4, null, Infinity, -2, 3, undefined]

=> 
var newArry8 = arr8.flat(Infinity);
console.log(newArry8);

14. Write the code. Addition of positive number in array.

var myArr1 = [1, 2, 3, 4, null, 'vishal', -2, true];
        var count1 = 0
        myArr1.forEach((element) => {
            if (typeof element === 'number' && element > 0) {
                count1 = count1 + element;
            }
        })
    console.log(count1) 
=> 10


15. Output of given code.
var salary = "1000";
        (function () {
            console.log("Original salary was " + salary);
            var salary = "5000";
            console.log("My New Salary " + salary);
        })();
        console.log("My New Salary " + salary);

=> 
Original salary was undefined
My New Salary 5000
My New Salary 1000
 
16. Output of given code.
var bar = true;
console.log(bar + 0); 
=> 1

17. Output of given code.
var trees = ["xyz", "xxxx", "test", "ryan", "apple"];
delete trees[3];
console.log(trees.length);
=> 5

18. Explain call stack.
19. Promises  in javascript
20. Async/Await 
21. ES5 Features
=> 
"use strict"
String.trim()
Array.isArray()
Array.forEach()
Array.map()
Array.filter()
Array.reduce()
Array.reduceRight()
Array.every()
Array.some()
Array.indexOf()
Array.lastIndexOf()
JSON.parse()
JSON.stringify()
Date.now()
Property Getters and Setters
New Object Property Methods

22. New Features in ES6
=> 
The let keyword
The const keyword
JavaScript Arrow Functions
JavaScript Class
JavaScript Promise
JavaScript Symbol
Default Parameter Values
Function Rest Parameter
Array.find()
Array.findIndex()
New Number Properties
New Number Methods
New Global Methods

23. JavaScript String padding and what is output of below code
let str = "5";
str = str.padStart(4,0);

=> 00005

24. JavaScript Classes and Constructor 
25. is it JavaScript Asynchronous or synchronous
26. Explain asynchronous
27. Difference Between call() and apply()
=>
The call() method takes arguments separately.
The apply() method takes arguments as an array.

28. Explain JavaScript Object Prototypes
29. Use of this Keyword in javascript
30. Difference between var, let and const.



Angular 7

1. What is Angular? 
=> Angular is an open-source front-end web framework. It is one of the most popular JavaScript frameworks that are mainly maintained by Google. 
It provides a platform for easy development of web-based applications and empowers the front end developers in curating cross-platform applications.  

2. What are the advantages of using Angular? 
=> A few of the major advantages of using Angular framework are listed below: 
 It supports two-way data-binding. .
 It follows MVC pattern architecture. 
 It supports static template and Angular template. 
 You can add a custom directive. 
 It also supports REST full services. 
 Validations are supported. 
 Support for dependency injection. 
 Has a strong feature like Event Handlers, Animation, etc.

3. Differentiate between Angular and Angular JS. 
=> 
Angular JS: 
 Supports MVC design model. 
 Recommended Language: JavaScript. 
 Doesn’t provide any mobile support. 
 Doesn’t support the concept of Dependency Injection. 
 With two-way data binding development effort and time are reduced. 
Angular: 
 Uses components and directives. 
 Recommended Language: TypeScript. 
 Provides mobile support. 
 Supports hierarchical Dependency Injection with a unidirectional tree-based change detection. 
 Faster than Angular JS with upgraded feature

4. What are directives in Angular? 
=>
Structural directives: 
The Structural Directives are responsible for the HTML layout. That means, 
they will shape or reshape the HTML view by simply adding or removing the elements from the DOM. 
These directives are basically used to handle how the component or the element should render in a template.
NgFor (*ngFor)
NgIf (*ngIf)
NgSwitch (*ngSwitch)


Attribute Directives: 
Attribute Directives are basically used to modify the behavior or appearance of the DOM element or the Component. 
In Angular, there are two in-built attribute directives available. They are as follows:
NgStyle
NgClass

Component Directives:
The Component is also a type of directive in angular with its own template, styles, and logic needed for the view. 
The Component Directive is the most widely used directive in the angular application and you cannot create an angular application without a component.
A component directive requires a view along with its attached behavior and this type of directive adds DOM Elements. 
The Component Directive is a class with @Component decorator function.

5.  What are angular decorators? 
=> There are 4 Types of decorators 
	1) Class decorators, e.g. @Component and @NgModule 
	2) Property decorators for properties inside classes, e.g. @Input and @Output 
	3) Method decorators for methods inside classes, e.g. @HostListener 
	4) Parameter decorators for parameters inside class constructors, e.g. @Inject 
	
6. What are the angular @NgModule metadata? 
=>
@NgModule({ 
    declarations:[Component1, Component2], 
    imports: [Module1, Module2], 
    exports: [MyModule], 
    providers: [Service1, Service2], 
    bootstrap: [AppComponent] 
}) 

7. What are the angular @Component metadata? 
=> 
@Component({ 
changeDetection?: ChangeDetectionStrategy 
viewProviders?: Provider[] 
moduleId?: string 
templateUrl?: string 
template?: string 
styleUrls?: string[] 
styles?: string[] 
animations?: any[] 
encapsulation?: ViewEncapsulation 
interpolation?: [string, string] 
entryComponents?: Array<Type<any> | any[]> 
preserveWhitespaces?: boolean 
 
// inherited from core/Directive 
selector?: string 
inputs?: string[] 
outputs?: string[] 
host?: {...} 
providers?: Provider[] 
exportAs?: string 
queries?: {...} 
})

8. What is data binding? 
=> Data binding is a core concept in Angular and allows to define communication between a component and the DOM, 
making it very easy to define interactive applications without worrying about pushing and pulling data.  

There are four forms of data binding and they differ in the way the data is flowing. 

1) Interpolation: {{ value }} => From the Component to the view 
      <li>Name: {{ user.name }}</li> 
      <li>Email: {{ user.email }}</li> 
2) Property binding: [property]=”value” => From the Component to the view 
      <img [src]="imagePath" class="image-adjustment"/> 
3) Event binding: (event)=”function” => From the view to the Component 
      <button (click)="cookBacon()"></button> 
4) Two-way data binding: [(ngModel)]=”value” = >  Two-way data binding allows to have the data flow both ways     
     <input type="email" [(ngModel)]="user.email"> 
	 
9. What is AOT? 
=> AOT stands for Angular Ahead-of-Time compiler. 
It is used for pre-compiling the application components and along with their templates during the build process. 
Angular applications which are compiled with AOT has a smaller launching time. 
Also, components of these applications can execute immediately, without needing any client-side compilation. 
Templates in these applications are embedded as code within their components. 
It reduces the need for downloading the Angular compiler which saves you from a cumbersome task. 
AOT compiler can discard the unused directives which are further thrown out using a tree-shaking tool.

10. What are pipes? Give me an example.  
=> A pipe takes in data as input and transforms it to a desired output. You can chain pipes together in potentially useful combinations. 
You can write your own custom pipes. Angular comes with a stock of pipes such as DatePipe, UpperCasePipe, LowerCasePipe, CurrencyPipe, and PercentPipe.
 
There are two types of pipes 
1) Build-in =>  
    a. Parameterized 
        {{appValue|Pipe1: parameter1: parameter2 }} 
        {{today | date:'MM-dd-yyyy' }}  
        {{salary | currency:'USD':true}} 
    b. Chaining 
        {{ today | date:'fullDate' | uppercase}} 
 
2)  Custome =>  
    a. Filter 
        {{ name | alphabet}}
		
11. What are the different types of filters in Angular?	
=>
uppercase
lowercase
titlecase
date
json
currency
number
keyvalue

12. What is Dependency Injection in Angular?  
=> Dependency Injection (DI) is a software design pattern where the objects are passed as dependencies rather than hard-coding them within 
the component. The concept of Dependency Injection comes in handy when you are trying to separate the logic of object creation to that of 2
its consumption. The ‘config’ operation makes use of DI that must be configured beforehand while the module gets loaded to retrieve the 
elements of the application. With this feature, a user can change dependencies as per his requirements. 	

13. What is angular lifecycle hooks? 
=>
 ngOnChanges() 
 ngOnInit() 
 ngDoCheck() 
 ngAfterContentInit() 
 ngAfterContentChecked() 
 ngAfterViewInit() 
 ngAfterViewChecked() 
 ngonDestroy()

14. What is Transpiling in Angular? 
=> Transpiling in Angular refers to the process of conversion of the source code from one programming language to another. 
In Angular, generally, this conversion is done from TypeScript to JavaScript. It is an implicit process and happens internally.

15. Application flow of angular? 

16. How to optimize Angular app? 
=> 
 Consider lazy loading instead of fully bundled app if the app size is more. 
 Make sure that any 3rd party library, which is not used, is removed from the application. 
 Have all dependencies and dev-dependencies are clearly separated. 
 Make sure the application doesn’t have un-necessary import statements. 
 Make sure the application is bundled, uglified, and tree shaking is done. 
 Consider AOT compilation.

17. How many types of compilation? 
=> Angular provides two types of compilation: 
1) JIT(Just-in-Time) compilation => In JIT compilation, the application compiles inside the browser during runtime. 
2) AOT(Ahead-of-Time) compilation => Whereas in the AOT compilation, the application compiles during the build time.

18. How does one share data between components in Angular?
=> 
Parent to child using @Input decorator
Child to parent using @Output and EventEmitter

19. What is the equivalent of ngShow and ngHide in Angular? 
=> Just bind to the hidden property 

20. What is the difference between *ngIf vs [hidden]? 
=> *ngIf effectively removes its content from the DOM while [hidden] modifies the display property and only instructs the 
browser to not show the content but the DOM still contains it. 


21. What is the difference between "@Component" and "@Directive" in Angular?  
=> 
Components have their own view (HTML and styles).  
Directives are just "behavior" added to existing elements and components. 

22. How would you protect a component being activated through the router? 
=> The Angular router ships with a feature called guards. These provide us with ways to control the flow of our application. 
We can stop a user from visitng certain routes, stop a user from leaving routes, and more. The overall process for protecting Angular routes: 
 CanActivate: Check if a user has access 
 CanActivateChild: Check if a user has access to any of the child routes 
 CanDeactivate: Can a user leave a page? For example, they haven't finished editing a post 
 Resolve: Grab data before the route is instantiated 
 CanLoad: Check to see if we can load the routes assets

23. How would you run unit test? 
=> ng test 

24. What is an observable? 
=> Angular uses Observable to treat asynchronous code. The same way that we use callbacks and promises in vanilla JavaScript. In fact, 
the Observable will be added to future versions of JavaScript, but until that happens it is implemented in Angular with the help of 
the RxJS library. Observables are widely used in Angular for handling asynchronous code. For example, to work with Ajax, 
when listening to events and navigating between the pages of an application (routing). To understand why we need to use 
asynchronous code instead of plain JavaScript, think about a code that waits for a response from a remote server. 
There is no way of knowing when the response will return, and whether it will ever come back, so it is not a good idea to stop 
executing the script until the response is received. Asynchronous code is a much better solution, and the way Angular prefers to 
handle asynchronous code is through observables. 

25. Explain the difference between `Promise` and `Observable` in Angular? 
=> 
Promise: Promises work with asynchronous operations. They either return a single value (i.e the promise resolves) or an error message 
(i.e the promise rejects). Another important thing to remember regarding promises is that a request initiated from a promise is not canceled.
 
Disadvantages of Promise: 
 User could not cancel a request to the API. 
 User could not retry a failed call. 
 As our application gets bigger, promises become hard to manage. 

Observable: An Observable is an array or a sequence of events over time. It has at least two participants, the creator 
(the data source) and the subscriber (subscription where data is being consumed). Compared to a promise, an observable can be canceled. 
RxJS is all about unifying the ideas of promise callbacks and data flow and making them easier to work with. 
Observables provide operators, like map, forEach, reduce...similar to an array.
There are also powerful operators like retry(),  reply(), retryWhen(), delay()

26. Explain the difference between "Constructor" and "ngOnInit" 
=> The main difference between constructor and ngOnInit is that ngOnInit is lifecycle hook and runs after constructor. 
Component interpolated template and input initial values aren't available in constructor, but they are available in ngOnInit.

27. How to bundle an Angular app for production? 
=> ng build --prod 

28. Type of loading in angular 
=> There are 3 types of loading. 
1) Eager Loading: In Eager loading, all the feature modules will be loaded before the application starts and all required dependencies will be resolved. 
2) Lazy Loading: Load the module on the user demand. When clicking on any module that time loads the module. 
3) Pre-Loading: A preload strategy creates rules that determine which modules to preload. So, if you have multiple lazy-loaded modules, 
a preloading strategy would determine which modules to preload and when to preload them.

29. What is the purpose of Wildcard route? 
=> A wildcard route has a path consisting of two asterisks. It matches every URL. 
The router will select this route if it can't match a route earlier in the configuration. 
A wildcard route can navigate to a custom "404 Not Found" component or redirect to an existing route 

eg. 
{ 
    path: '**', component: PageNotFoundComponent 
} 

30. What is router outlet? 
=> Router-outlet in Angular works as a placeholder which is used to load the different components dynamically based on the activated component or current route state.To enable routing, we need to use router-outlet into our HTML template like this. 
<router-outlet></router-outlet> 

31. What are RxJS subjects? 
=> Subjects are used for multicasting Observables. This means that Subjects will make sure each subscription 
gets the exact same value as the Observable execution is shared among the subscribers. You can do this using the Subject class.

32. variants of RxJS subjects 
=>  
Subject: A special type of Observable which shares a single execution path among observers 
 
Behavior subject: Requires an initial value and emits the current value to new subscribers. 

Replay subject: Replays or emits old values to new subscribers 
 
Async subject: Emits its last value on completion 

33. What is encapsulation? 
=> The View Encapsulation in Angular is a strategy which determines how angular hides (encapsulates) the styles defined in the 
component from bleeding over to the the other parts of the application. 

The following three strategies provided by the Angular to determine how styles are applied. 

 ViewEncapsulation.None 
 ViewEncapsulation.Emulated 
 ViewEncapsulation.ShadowDOM

1. The ViewEncapsulation.None is used, when we do not want any encapsulation. 
When you use this, the styles defined in one component affects the elements of the other components.

2. This strategy isolates the component styles. They do not bleed out to other components. 
The global styles may affect the element styles in the component The Angular adds the attributes to the styles and mark up

34. How to Use Change Detection in Angular?
=>Change Detection means updating the DOM whenever data is changed. Angular provides two strategies for Change Detection. 
In its default strategy, whenever any data is mutated or changed, Angular will run the change detector to update the DOM. 
In the onPush strategy, Angular will only run the change detector  when a new reference is passed to @Input() data. 
To update the DOM with updated data, Angular provides its own change detector to each component, 
which is responsible for detecting change and updating the DOM. 

35. Pure and Impure Pipes in Angular? 
=>
Async Pipe - This is an impure pipe. As async pipe deals with observables, it is marked as impure. This pipe has its own internal state which 
deals with the subscription of the observables under the hood. Angular has to create the instance of this pipe every single time as 
it is used with different observables. We can't use the same instance of this pipe as this will interfere observables with each other. 
This pipe is called on every change detection cycle as observable can produce new value at any point in time. 
So we need to process the value at every digest cycle. 

JsonPipe and SlicePipe - These both pipes are considered impure as the inputs passed to both are mutable. 
If the input is of type mutable, we need to call the pipe at every change detection cycle. An input object can be changed without 
changing the object reference. These both pipes doesn't have any internal state. But still considered as impure.

36. Difference between Reactive forms and Template driven forms in Angular

37. Difference Between setValue() And patchValue() In Angular? 
=>
setValue(): method will set all fromcontrol values from model. If you do not mention any of the formcontrol values in model,then it will throw an 
exception. 
patchValue(): 
patchValue() method will also set Formcontrol values from a model but only for those which we have mentioned in the model. So,  
it is not necessary to pass all the model info in patchValue() method.

38. Difference Between valueChanges and statusChanges In Angular
=> valueChanges and statusChanges both return Observable instance and we can subscribe them to get data. 
valueChanges emits an event every time when the value of control changes either using UI or programmatically. 
statusChanges emits an event every time when the validation status of the control is recalculated. 
statusChanges gives current validation status of a control. valueChanges gives current value of a control. 
valueChanges can be used for conditional validation in reactive form. 


39. Explain dynamic component or entyLevel components
=> Component templates are not always fixed. An application may need to load new components at runtime.







Redux

1. What is the difference between React context and React Redux?
=> CONTEXT: 
    You can use Context in your application directly and is going to be great for passing down 
    data to deeply nested components which what it was designed for.
   REDUX:

2. What is redux?
=> Redux is a predictable state container for JavaScript apps which makes it possible to use a centralized state management in your application.


Redux can be used with any modern JavaScript-based web frameworks. Before starting to build our Angular Redux sample application let’s first clarify the core concept of Redux.
Redux organizes your application state in the store, a single data structure in your application. The components of your application read the state of the application from the store. The store is never mutated directly. Instead a action is dispatched to a reducer function. The reducer function creates a new application state by combining the old state and the mutations defined by the action.
Let’s explore the building blocks of Redux one by one:


Store:
The store is a single JS object. To create a store you simple need to a add a TypeScript file to the project and declare a new interface type 
which contains all the properties you’d like to keep in the store.

Actions:
Actions are plain JS objects that represent something that has happened. Can be compared to events.

Reducers:
A reducer is a function that specifies how the state changes in response to an action.


3. What are the core principles of Redux?
=>
    1. Single source of truth: The state of your whole application is stored in an object tree within 
       a single store. The single state tree makes it easier to keep track of changes over time and debug 
       or inspect the application.

    2. State is read-only: The only way to change the state is to emit an action, an object describing 
    what happened. This ensures that neither the views nor the network callbacks will ever write 
    directly to the state.

    3. Changes are made with pure functions: To specify how the state tree is transformed by actions, 
    you write reducers. Reducers are just pure functions that take the previous state and an action 
    as parameters, and return the next state.

4. How to use connect() from React Redux?

5. What is redux-saga?
=> 
    redux-saga is a library that aims to make side effects (asynchronous things like data fetching and impure things like accessing the browser cache) in React/Redux applications easier and better.
    It is available in NPM:
    $ npm install --save redux-saga

6. What is Redux Thunk?
=> 
    Redux Thunk middleware allows you to write action creators that return a function instead of an action. 
    The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. 
    The inner function receives the store methods dispatch() and getState() as parameters.

7. What are the differences between redux-saga and redux-thunk?
=> Both Redux Thunk and Redux Saga take care of dealing with side effects. 
   In most of the scenarios, Thunk uses Promises to deal with them, whereas Saga uses Generators. 
   Thunk is simple to use and Promises are familiar to many developers, 
   Sagas/Generators are more powerful but you will need to learn them. 
   But both middleware can coexist, so you can start with Thunks and introduce Sagas when/if you need them.


Testing

1. How to write test case in angular.
2. Which testing tool use of unit testing in angular.
3. How to run test case.
4. Can you write one test case for below function
function helloWorld() {
  return 'Hello world!';
}
=>

We would write a Jasmine test spec like so:

TypeScript
describe('Hello world', () => { (1)
  it('says hello', () => { (2)
    expect(helloWorld()) (3)
        .toEqual('Hello world!'); (4)
  });
});


The describe(string, function) function defines what we call a Test Suite, a collection of individual Test Specs.
The it(string, function) function defines an individual Test Spec, this contains one or more Test Expectations.
The expect(actual) expression is what we call an Expectation. In conjunction with a Matcher it describes an expected piece of behaviour in the application.
The matcher(expected) expression is what we call a Matcher. It does a boolean comparison with the expected value passed in vs. 
the actual value passed to the expect function, if they are false the spec fails.

5. Jasmine comes with a few pre-built matchers. can you tell me that matchers

=> 
expect(array).toContain(member);
expect(fn).toThrow(string);
expect(fn).toThrowError(string);
expect(instance).toBe(instance);
expect(mixed).toBeDefined();
expect(mixed).toBeFalsy();
expect(mixed).toBeNull();
expect(mixed).toBeTruthy();
expect(mixed).toBeUndefined();
expect(mixed).toEqual(mixed);
expect(mixed).toMatch(pattern);
expect(number).toBeCloseTo(number, decimalPlaces);
expect(number).toBeGreaterThan(number);
expect(number).toBeLessThan(number);
expect(number).toBeNaN();
expect(spy).toHaveBeenCalled();
expect(spy).toHaveBeenCalledTimes(number);
expect(spy).toHaveBeenCalledWith(...arguments);


6. What is beforeAll,afterAll,beforeEach and afterEach
=> 
beforeAll:
This function is called once, before all the specs in a test suite (describe function) are run.
afterAll:
This function is called once after all the specs in a test suite are finished.
beforeEach:
This function is called before each test specification (it function) is run.
afterEach:
This function is called after each test specification is run.

7. What is jest
8. Difference between jest and karma.




LitElement and WebComponent
1. What is lit element
=>
LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework. 
LitElement uses lit-html to render into shadow DOM, and adds API to manage properties and attributes

2. What is web components?
=> Web Components is a suite of different technologies allowing you to create reusable custom elements
with their functionality encapsulated away from the rest of your code and utilize them in your web apps.


3. Why web component ?
=> we all know that reusing code as much as possible is a good idea. This has traditionally not been so easy for custom markup structures
think of the complex HTML (and associated style and script) you’ve sometimes had to write to render custom UI controls, 
and how using them multiple times can turn your page into a mess if you are not careful. 

Reusability
Maintainability
Productivity
Composability
Following web standard



Storybook:

1. What is storybook in angular
=> Storybook runs alongside your app in development mode. It helps you build UI components isolated from the business logic and context of your app.

accessibility:


React

1. What is React? 
=> A javascript library to build user interfaces.

2. What are the advantages of using React? 
=> 
    1. Increases the application’s performance with Virtual DOM.
    2. JSX makes code easy to read and write.
    3. It renders both on client and server side (SSR).
    4. Easy to integrate with frameworks (Angular, Backbone) since it is
    only a view library.
    5. Easy to write unit and integration tests with tools such as Jest.

3. What are the limitations of React?
=>
    1. React is just a view library, not a full framework.
    2. There is a learning curve for beginners who are new to web develop-
    ment.
    3. Integrating React into a traditional MVC framework requires some
    additional configuration.
    4. The code complexity increases with inline templating and JSX.
    5. Too many smaller components leading to over engineering or boiler- plate.

4. Why is a component constructor called only once?
=> 
    Because of React’s reconciliation algorithm assumes that without any information to the contrary, 
    if a custom component appears in the same place on subse-quent renders, it’s the same component as before, 
    so reuses the previous instance rather than creating a new one.

5. What are render props?
=>  
    Render Props is a simple technique for sharing code between components using a prop 
    whose value is a function. The below component uses render prop which returns a React element.
    jsx harmony <DataProvider render={data => (   <h1>{`Hello
    ${data.target}`}</h1> )}/>


3. React component lifecycle?
=> 
    Mounting
        1. constructor()
        2. static getDerivedStateFromProps()
        3. render()
        4. componentDidMount()

     Updating
        1. static getDerivedStateFromProps()
        2. shouldComponentUpdate()
        3. render()
        4. getSnapshotBeforeUpdate()
        5. componentDidUpdate()

     Unmounting
        1. componentWillUnmount()

     Error Handling
        1. setState()
        2. forceUpdate()

3. React component lifecycle?
=>

4. What is functional component? 
=>

5. Which component is better class based component or functional component & why?
=>

6. What are Higher Order Components(HOC)?
=>    
    Higher Order Component is an advanced way of reusing the component logic. 
    Basically, it’s a pattern that is derived from React’s compositional nature. 
    HOC are custom components which wrap another component within it. 
    They can accept any dynamically provided child component but they won’t modify or copy any behavior from their input components. 
    You can say that HOC are ‘pure’ components.

7. What can you do with HOC?
=>  
    HOC can be used for many tasks like:
    Code reuse, logic and bootstrap abstraction
    Render High jacking
    State abstraction and manipulation
    Props manipulation

8. What are Pure Components?
=>  
    Pure components are the simplest and fastest components which can be written. 
    They can replace any component which only has a render(). 
    These components enhance the simplicity of the code and performance of the application.

9. What is axios?
=>

10. Difference between Real DOM vs Virtual DOM?

11. What is the difference between mapStateToProps() and mapDispatchToProps()?

12. What is diffing algorithm?
=> 
    React needs to use algorithms to find out how to eﬀiciently update the UI to match the most recent tree. 
    The diﬀing algorithms is generating the minimum number of operations to transform one tree into another. 
    However, the algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree.
    In this case, for displaying 1000 elements would require in the order of one billion comparisons. 
    This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:
        1. Two elements of different types will produce different trees.
        2. The developer can hint at which child elements may be stable across
    different renders with a key prop.